/*
 * LMS.h
 *
 * Created: 2016/11/18 9:08:30
 *  Author: Administrator
 */ 
#include "lms.h"


//命令的下载数据帧0：message[length]={DataByte_n,...DataByte_0,CRC16L,CRC16H}
//命令的下载数据帧1：message[length]={DataByte_n,...DataByte_0,CRC16L,CRC16H}
//2.帧接收和效验
//2.1  7bit HanmingCode
BYTE const TxSyncFrame[]=
{
	//SS   LS_Frame  //SS message             //LS message
	0x00,0x0b,       //g2g1g0ID=0000,Group0_SS//g2g1g0ID=0001,Group0_LS    
	0x15,0x1e,       //g2g1g0ID=0010,Group1_SS//g2g1g0ID=0011,Group1_LS
	0x26,0x2d,       //g2g1g0ID=0100,Group2_SS//g2g1g0ID=0101,Group2_LS
	0x33,0x38,       //g2g1g0ID=0110,Group3_SS//g2g1g0ID=0111,Group3_LS
	0x47,0x4c,       //g2g1g0ID=1000,Group4_SS//g2g1g0ID=1001,Group4_LS
	0x52,0x59,       //g2g1g0ID=1010,Group5_SS//g2g1g0ID=1011,Group5_LS
	0x61,0x6a,       //g2g1g0ID=1100,Group6_SS//g2g1g0ID=1101,Group6_LS
	0x74,0x7f        //g2g1g0ID=1110,Group7_SS//g2g1g0ID=1111,Group7_LS
};
//2.1.1同步帧编码
//对4bit信息（g2g1g0ID采用能纠正1位错误的或检出2位错误的（7，4）汉明码编码
//输入：byValue=00000g2g1g0;IDType=00000000(SS),00000001(LS)
//返回：SyncFrame=0g2g1g0 ID c2c1c0
//
//查表法
BYTE GenSyncFrame(BYTE byGroupNo,BYTE IDType)
{
	return TxSyncFrame[(byGroupNo<<1)|IDType];
}
//计算法,用于验证查表法
BYTE Cal_GenSyncFrame(BYTE byGroupNo,BYTE IDType)
{
	BYTE SyncFrame=0x00,c2=0x00,c1=0x00,c0=0x00;
	
	SyncFrame=(byGroupNo<<1)|IDType;
	c2=((SyncFrame>>1)&0x04)^(SyncFrame&0x04)^((SyncFrame<<1)&0x04);        //c2=a6+a5+a4
	c1=((SyncFrame>>2)&0x02)^((SyncFrame>>1)&0x02)^((SyncFrame<<1)&0x02);   //c1=a6+a5+a3
	c0=((SyncFrame>>3)&0x01)^((SyncFrame>>1)&0x01)^(SyncFrame&0x01);        //c0=a6+a4+a3
	SyncFrame=(SyncFrame<<3)|c0|c1|c2;
	return SyncFrame;
}
//2.1.2同步帧解码
#define Bit(x)        (1<<(x))
//输入：byValue(7,4汉明码)=0 a6 a5 a4 a3 a2 a1 a0
//返回：ID Errorflag 0 0 0 g2 g1 g0
//      纠正后(Errorflag=1)，码组在TxSyncFrame[]中不存在，返回0xf0,
//      纠正后(Errorflag=1)，码组在TxSyncFrame[]中存在，只能由主程序根据组号或随后的信息，判别SyncFrame是否有效啦。
BYTE const Errorpattern[]={	0x00,0x01,0x02,0x04,0x03,0x05,0x06,0x07 };
//  s2|s1|s0      errorBit
//  001           a0
//  010           a1
//  011           a2
//  100           a3
//  101           a4
//  110           a5
//  111           a6
//  000           No Error
BYTE DeSyncFrame(BYTE byValue)
{
	BYTE RxSyncFrame=(byValue&0x7f),ErrorBitLocation=0x00,s2=0x00,s1=0x00,s0=0x00;
	
	s2=((RxSyncFrame>>4)&0x04)^((RxSyncFrame>>3)&0x04)^((RxSyncFrame>>2)&0x04)^(RxSyncFrame&0x04); //s2=a6+a5+a4+a2=bit2
	s1=((RxSyncFrame>>5)&0x02)^((RxSyncFrame>>4)&0x02)^((RxSyncFrame>>2)&0x02)^(RxSyncFrame&0x02); //s1=a6+a5+a3+a1=bit1
	s0=((RxSyncFrame>>6)&0x01)^((RxSyncFrame>>4)&0x01)^((RxSyncFrame>>3)&0x01)^(RxSyncFrame&0x01); //s0=a6+a4+a3+a0=bit0
	ErrorBitLocation=Errorpattern[(s2|s1|s0)];
	
	if (ErrorBitLocation==0x00)
	{
		return ((RxSyncFrame>>4)&0x07)|((RxSyncFrame<<4)&0x80);
	}
	else
	{
		RxSyncFrame^=Bit(ErrorBitLocation-1);//纠正1bit错误
		//检查是否为有效码组
		s0=0;
		for (s1=0;s1<=15;s1++)
		{
			if (RxSyncFrame==TxSyncFrame[s1])
			{
				s0++;
			}
		}
		if (s0==1)
		{
			return (((RxSyncFrame>>4)&0x07)|((RxSyncFrame<<4)&0x80))|0x40;
		}
		else
		{
			return 0xf0;
		}
	}
}
//2.2  CRC
//2.2.1 LS命令数据接收效验
//crc4/ITU=x^4+x+1,特征码或Poly=0001,0011=0x13，CRC4宽度=4
//TX mode:
//输入：message[]={data_n,data_n-1,data1,data0},以tx_LS为例，message[]={data1=1 s6-s0,data0=o7-o4 0 0 0 0}
//返回：crc4=0000c2c1c0
//RX mode:
//输入：message[]={data_n,data_n-1,data1,data0,crc4=0000c2c1c0},以rx_LS为例，message[]={data1=1 s6-s0,data0=o7-o40000,crc4=0000c2c1c0}
//返回：若=0x00,数据块接收正确，其它结果，数据块接收错误！
BYTE crc4_itu(BYTE * message,BYTE length)
{
	BYTE i;
	BYTE crc = 0;                          // Initial value
	
	while(length--)
	{
		crc ^= *message++;                 // crc ^= *data; data++;
		for (i=0;i<8;++i)
		{
			if (crc&0x01)
			{
				crc = (crc >> 1) ^ 0x0C;  // 0x0C = (reverse 0x03)>>(8-4)
			}
			else
			{
				crc = (crc >> 1);
			}
		}
	}
	return crc;
}
//2.2.2 LS的LMS/LMS编程数据接收效验
//crc16/modbus=x^16+x^15+x^2+1,特征码或Poly=1,1000,0000,0000,0101=0x18005
//查表法计算crc16/modbus
BYTE const CRC16_HTab[]=
{
	0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,
	0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
	0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
	0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,
	0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
	0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,
	0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,
	0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
	0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
	0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,
	0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,
	0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
	0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,
	0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
	0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
	0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40
};
BYTE const CRC16_LTab[]=
{
	0x00,0xC0,0xC1,0x01,0xC3,0x03,0x02,0xC2,0xC6,0x06,0x07,0xC7,0x05,0xC5,0xC4,0x04,
	0xCC,0x0C,0x0D,0xCD,0x0F,0xCF,0xCE,0x0E,0x0A,0xCA,0xCB,0x0B,0xC9,0x09,0x08,0xC8,
	0xD8,0x18,0x19,0xD9,0x1B,0xDB,0xDA,0x1A,0x1E,0xDE,0xDF,0x1F,0xDD,0x1D,0x1C,0xDC,
	0x14,0xD4,0xD5,0x15,0xD7,0x17,0x16,0xD6,0xD2,0x12,0x13,0xD3,0x11,0xD1,0xD0,0x10,
	0xF0,0x30,0x31,0xF1,0x33,0xF3,0xF2,0x32,0x36,0xF6,0xF7,0x37,0xF5,0x35,0x34,0xF4,
	0x3C,0xFC,0xFD,0x3D,0xFF,0x3F,0x3E,0xFE,0xFA,0x3A,0x3B,0xFB,0x39,0xF9,0xF8,0x38,
	0x28,0xE8,0xE9,0x29,0xEB,0x2B,0x2A,0xEA,0xEE,0x2E,0x2F,0xEF,0x2D,0xED,0xEC,0x2C,
	0xE4,0x24,0x25,0xE5,0x27,0xE7,0xE6,0x26,0x22,0xE2,0xE3,0x23,0xE1,0x21,0x20,0xE0,
	0xA0,0x60,0x61,0xA1,0x63,0xA3,0xA2,0x62,0x66,0xA6,0xA7,0x67,0xA5,0x65,0x64,0xA4,
	0x6C,0xAC,0xAD,0x6D,0xAF,0x6F,0x6E,0xAE,0xAA,0x6A,0x6B,0xAB,0x69,0xA9,0xA8,0x68,
	0x78,0xB8,0xB9,0x79,0xBB,0x7B,0x7A,0xBA,0xBE,0x7E,0x7F,0xBF,0x7D,0xBD,0xBC,0x7C,
	0xB4,0x74,0x75,0xB5,0x77,0xB7,0xB6,0x76,0x72,0xB2,0xB3,0x73,0xB1,0x71,0x70,0xB0,
	0x50,0x90,0x91,0x51,0x93,0x53,0x52,0x92,0x96,0x56,0x57,0x97,0x55,0x95,0x94,0x54,
	0x9C,0x5C,0x5D,0x9D,0x5F,0x9F,0x9E,0x5E,0x5A,0x9A,0x9B,0x5B,0x99,0x59,0x58,0x98,
	0x88,0x48,0x49,0x89,0x4B,0x8B,0x8A,0x4A,0x4E,0x8E,0x8F,0x4F,0x8D,0x4D,0x4C,0x8C,
	0x44,0x84,0x85,0x45,0x87,0x47,0x46,0x86,0x82,0x42,0x43,0x83,0x41,0x81,0x80,0x40
};
//TX mode:
//输入：message[length]={DataUint8_t_n,...DataByte_0}
//返回：双字节无符号数，CRC16H，CRC16L
//RX mode:
//输入：message[length]={DataByte_n,...DataByte_0,CRC16L,CRC16H}
//返回：若=0x0000,数据块接收正确，其它结果，数据块接收错误！
WORD crc16_modbus(BYTE * message,BYTE length)
{
	BYTE i;
	BYTE uchCRCHi = 0xFF ; /* high byte of CRC initialized */
	BYTE uchCRCLo = 0xFF ; /* low byte of CRC initialized */
	BYTE uIndex; /* will index into CRC lookup table */

	for(i = 0; i < length; i++)// (usDataLen--) /* pass through message buffer */
	{
		uIndex = uchCRCLo ^ message[i];//arrData[i]; /* calculate the CRC */
		uchCRCLo = uchCRCHi ^ CRC16_HTab[uIndex];//auchCRCHi[uIndex] ;
		uchCRCHi = CRC16_LTab[uIndex];//auchCRCLo[uIndex] ;
	}
	return (uchCRCHi << 8 | uchCRCLo);
}
//2.4 LMS编程
//******************编程数据数组定义*******************//
//eeprom Addr Scope=0x0000=0x0800
#define  ProgBlock0BaseAddr        0x0000
#define  ProgBlock1BaseAddr        0x0020
WORD ProgBlock_EEPROMBaseAddrTab[2] =
{
	ProgBlock0BaseAddr,ProgBlock1BaseAddr
};
//RxProgBlock0
#define  pConSegAddr        0
#define  pGroupAddr         1
BYTE RxProgBlock0[]=
{
	0x10,		//ConSegAddr=0-127
	1,			//Group0Addr
	0,			//Group1Addr
	4,			//Group2Addr
	0,			//Group3Addr
	7,			//Group4Addr
	0,			//Group5Addr
	5,			//Group6Addr
	0,			//Group7Addr
	0x05,		//modbus crc16_L
	0x5c		//modbus crc16_H
};
//RxProgBlock1
#define  pPowerOnorder        0
#define  pTp_TxDelayNum       4

BYTE RxProgBlock1[]=
{
	0x40,       //PowerOnorder;上电/复位后LMS/SIU设置	：（1）PowerOnorder=0x80=SIU,（2）PowerOnorder=0x40=LMS上电后自动亮灯,PowerOnorder=0x41=LMS上电后自动关灯
	0x01,       
	0x01,       
	42,         
	40,         //Tp_TxDelayNum（TStd的倍数）;电流的10ms零点到允许发射BFSK的延时时间=Tp_TxDelay=Tp_TxDelayNum*TStd
	0x13, 	            
	0xff,       
	0x07,        
	0x6f,       //modbus crc16_L
	0xa2        //modbus crc16_H
};
//
#define  pBlock0Length        sizeof(RxProgBlock0)
#define  pBlock1Length        sizeof(RxProgBlock1)
WORD ProgBlock_LengthTab[2] =
{
	pBlock0Length,pBlock1Length
};
//******************LMS/LMS运行参数*******************//
//1.结构定义
typedef struct LMS
{
	BYTE  PowerOnCon;                 //上电/复位后LMS控制灯具亮或灭，0x40为LMS上电或复位后控制灯具亮，其它值为控制灯具灭
	BYTE  ConSegNo;                   //0x00-0x7f
	BYTE  GroupNo[8];                 //0x01-0x08,GroupNo[8]=0x00为未配置组地址或无效组地址		

	BYTE  TxDelayTNT;	              //电流10ms零点到开始发射BFSK的延时时间，Tp_TxDelay=Tp_TxDelayNum*TStd
} LMS;

//3.数据块EEPROM读写和LMS参数初始化
//3.1 编程数据写入和读出EEPROM
//eepromAddr=0x000-0x800
// void Write_eepromByte(BYTE Value,WORD addr)
// {
// 	eeprom_write_byte ((BYTE*)addr,Value);
// 	eeprom_busy_wait();
// }
// BYTE Read_eepromByte(WORD addr)
// {
// 	BYTE Value;
// 	Value=eeprom_read_byte ((BYTE*)addr);
// 	eeprom_busy_wait();
// 	return Value;
// }
// //写编程数据块0，正确返回值=1，其它=0
// BYTE WriteProgBlock0(void)
// {
// 	BYTE i;
// 	WORD addr;
	
// 	if (crc16_modbus(RxProgBlock0,pBlock0Length)==0x0000)
// 	{
// 		addr=ProgBlock0BaseAddr;
// 		for (i=0;i<pBlock0Length;i++)
// 		{
// 			Write_eepromByte(RxProgBlock0[i],addr);
// 			addr++;
// 		}
// 		return TRUE;
// 	}
// 	else
// 	{
// 		return FALSE;
// 	}
// }
// //写编程数据块1，正确返回值=1，其它=0
// BYTE WriteProgBlock1(void)
// {
// 	BYTE i;
// 	WORD addr;
	
// 	if (crc16_modbus(RxProgBlock1,pBlock1Length)==0x0000)
// 	{
// 		addr=ProgBlock1BaseAddr;
// 		for (i=0;i<pBlock1Length;i++)
// 		{
// 			Write_eepromByte(RxProgBlock1[i],addr);
// 			addr++;
// 		}
// 		return TRUE;
// 	}
// 	else
// 	{
// 		return FALSE;
// 	}
// }
// //3.2 初始化LMS 运行参数
// //init_gLMS(& gLMS);
// void init_gLMS(LMS *p)
// {
// 	BYTE i;
// 	WORD addr;
// 	float Temp;
	
// 	addr=ProgBlock0BaseAddr;
// 	for (i=0;i<pBlock0Length;i++)
// 	{
// 		RxProgBlock0[i]=Read_eepromByte(addr);
// 		addr++;
// 	}
// 	addr=crc16_modbus(RxProgBlock0,pBlock0Length);
// 	if (addr==0x0000)
// 	{
// 		//使用eeprom数据
// 		Clr_LoadOkLamp();
// 		p->ConSegNo=RxProgBlock0[pConSegAddr];
// 		for (i=pGroupAddr;i<=8;i++)
// 		{
// 			p->GroupNo[i-1]=RxProgBlock0[i];
// 		}
// 	}
// 	else
// 	{
// 		//使用缺省数据
// 		Set_LoadOkLamp();
// 		p->ConSegNo=0x20;		   //控制段地址
// 		p->GroupNo[0]=0x01;        //组0地址
// 		p->GroupNo[1]=0x02;        //组1地址
// 		p->GroupNo[2]=0x03;        //组2地址
// 		p->GroupNo[3]=0x04;        //组3地址
// 		p->GroupNo[4]=0x05;        //组4地址
// 		p->GroupNo[5]=0x06;        //组5地址
// 		p->GroupNo[6]=0x07;        //组6地址
// 		p->GroupNo[7]=0x08;        //组7地址
// 	}	
// 	addr=ProgBlock1BaseAddr;
// 	for (i=0;i<pBlock1Length;i++)
// 	{
// 		RxProgBlock1[i]=Read_eepromByte(addr);
// 		addr++;
// 	}
// 	addr=crc16_modbus(RxProgBlock1,pBlock1Length);
// 	if (addr==0x0000)
// 	{
// 		//使用eeprom数据
// 		Clr_LoadOkLamp();
// 		p->PowerOnCon=RxProgBlock1[pPowerOnorder];                             //LMS/SIU类型，LMS上电后保持亮或灭
// 		//
// 		Temp=(float)RxProgBlock1[pTp_TxDelayNum]*TStd;                         //unit:s
// 		p->TxDelayTNT=Init8bit_TimerValue(Temp*1000,TxDelay_div);
// 		//
// 	}
// 	else
// 	{
// 		//使用缺省数据
// 		Set_LoadOkLamp();
// 		p->PowerOnCon=0x40;                    //设备类型设定为LMS，上电/复位后灯具亮
// 		//		
// 		Temp=10.0f*TStd;					   //1ms,unit:s
// 		p->TxDelayTNT=Init8bit_TimerValue(Temp*1000,TxDelay_div);
// 		//
// 	}
// }

